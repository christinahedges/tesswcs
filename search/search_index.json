{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#tesswcs","title":"tesswcs","text":"<p>This package will enable you to create an <code>astropy</code> World Coordinate System for any pointing of the TESS telescope. You can access both the true WCS from archival data, and predict the WCS for a given RA, Dec, and spacecraft roll.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>tesswcs</code> using <code>pip</code></p> <pre><code>pip install --upgrade tesswcs\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Below is an example of how to obtain a WCS for archival data</p> <pre><code>import tesswcs\n\nwcs = tesswcs.WCS.from_archive(sector=1, camera=1, ccd=1)\n</code></pre> <p>Using <code>astropy</code>'s WCS interface you can now either work with this object, for example you can obtain the sky position of row and column positions</p> <pre><code>wcs.pixel_to_world(row, column)\n</code></pre> <p>or obtain row and column positions from sky positions (using the <code>astropy.coordinates.SkyCoord</code> object).</p> <pre><code>from astropy.coordinates import SkyCoord\nwcs.world_to_pixel(SkyCoord.from_name(\"HD 209458\"))\n</code></pre> <p>You can also save these objects to fits files</p> <pre><code>wcs.to_fits('wcs.fits')\n</code></pre> <p>If you have a RA, Dec and roll in degrees you can also predict a WCS</p> <pre><code>import tesswcs\n\nwcs = tesswcs.WCS.predict(ra=0, dec=0, roll=0, camera=1, ccd=1)\n</code></pre>"},{"location":"tutorial/","title":"How to use <code>tesswcs</code>","text":"<p>The <code>tesswcs</code> package is designed to help users:</p> <ol> <li>Obtain the true World Coordinate System for TESS (Transiting Exoplanet Survey Satellite) data that is archived.</li> <li>Predict the World Coordinate System for TESS Cameras and CCDs based on an RA (Right Ascension), Dec (Declination), and Roll pointing of the boresight.</li> </ol> <p>In this tutorial, we show how to work with the <code>tesswcs</code> package to get pointing information for the telescope.</p>"},{"location":"tutorial/#a-brief-recap-on-wcs","title":"A brief recap on WCS","text":"<p>The World Coordinate System (WCS) is a standard in astronomy for representing coordinates of celestial objects. It's a system that maps the pixels of an image to real-world coordinates (like RA and Dec in the sky). This is crucial for understanding where exactly an astronomical image is pointing. WCS information in this case will enable us to understand which targets will fall on TESS pixels for any given pointing of the spacecraft.</p> <p>WCS information is typically stored in the header of FITS (Flexible Image Transport System) files, a common file format used in astronomy. The WCS headers contain the necessary parameters to translate between pixel coordinates in the image and sky coordinates.</p>"},{"location":"tutorial/#a-brief-recap-on-astropywcswcs","title":"A brief recap on <code>astropy.wcs.WCS</code>","text":"<p><code>astropy.wcs.WCS</code> is a class provided by the Astropy package, a powerful tool for astronomy data analysis and handling in Python. The <code>WCS</code> class in Astropy is used to handle the World Coordinate System information of FITS files.</p> <p>This class can parse the WCS information from FITS headers and provide a simple interface to convert between pixel coordinates and sky coordinates. Some common operations using <code>astropy.wcs.WCS</code> include:</p> <ul> <li>Converting pixel coordinates to celestial coordinates and vice versa.</li> <li>Handling different types of projections and coordinate transformations.</li> <li>Dealing with distortions present in the data.</li> </ul>"},{"location":"tutorial/#what-is-new-in-tesswcswcs","title":"What is new in <code>tesswcs.WCS</code>?","text":"<p><code>tesswcs</code> provides you with a \"subclass\" of <code>astropy.wcs.WCS</code>. As such, the <code>tesswcs.WCS</code> class provides the same functionality as <code>astropy.wcs.WCS</code>, including working with WCS objects and storing them as fits files. The <code>tesswcs.WCS</code> has new methods and attributes, which enables you to do the following;</p>"},{"location":"tutorial/#new-class-methods","title":"New class methods","text":"<p>To create the WCS for tess you can use one of two class methods. To obtain the true WCS from an archived dataset, you can use</p> <pre><code>wcs = tesswcs.WCS.from_archive(sector=1, camera=1, ccd=1)\n</code></pre> <p>To predict a WCS based on a boresight RA, Dec and Roll, you can use <pre><code>wcs = tesswcs.WCS.predict(ra=352.6844, dec=-64.8531, roll=222.1532, sector=1, camera=1, ccd=1)\n</code></pre></p>"},{"location":"tutorial/#new-class-attributes","title":"New class attributes","text":"<p>If you initialize a <code>tesswcs.WCS</code> class object <pre><code>wcs = tesswcs.WCS.from_archive(sector=1, camera=1, ccd=1)\n</code></pre></p> <p>you can access the RA, Dec, and Roll of the boresight pointing of TESS using class attributes, e.g. <pre><code>wcs.ra, wcs.dec, wcs.roll\n</code></pre> will return  <pre><code>(352.6844, -64.8531, 222.1532)\n</code></pre></p> <p>and you can access the camera and CCD number  <pre><code>wcs.camera, wcs.ccd\n</code></pre> will return <pre><code>(1, 1)\n</code></pre></p> <p>In the case of pointing information on archived TESS data, you can also access the sector, e.g.</p> <p><pre><code>wcs.sector\n</code></pre> will return  <pre><code>1\n</code></pre></p>"},{"location":"tutorial/#how-do-i-use-it","title":"How do I use it?","text":"<p>Below we show a tutorial on how to work with the <code>tesswcs.WCS</code> class.</p> <pre><code>from tesswcs import WCS\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport astropy.units as u\n</code></pre> <p>First, to load a WCS from TESS data that has already been archived, we can use the <code>from_archive</code> method:</p> <pre><code>wcs = WCS.from_archive(sector=1, camera=1, ccd=1)\n</code></pre> <p>If we print <code>wcs</code>, can see the key parameters of the WCS</p> <pre><code>wcs\n</code></pre> <pre><code>WCS Keywords\n\nNumber of WCS axes: 2\nCTYPE : 'RA---TAN-SIP'  'DEC--TAN-SIP'  \nCRVAL : 319.40344268202983  -41.281972194879756  \nCRPIX : 1045.0  1001.0  \nPC1_1 PC1_2  : 0.005481380474769502  -0.001728607226633  \nPC2_1 PC2_2  : 0.001590229789019981  0.005438735789549773  \nCDELT : 1.0  1.0  \nNAXIS : 2078  2136\n</code></pre> <p>Remember, the <code>tesswcs.WCS</code> has special attributes, the <code>ra</code>, <code>dec</code>, and <code>roll</code> attributes show the properties of the boresight.</p> <pre><code>wcs.ra, wcs.dec, wcs.roll\n</code></pre> <pre><code>(352.6844, -64.8531, 222.1532)\n</code></pre> <p>To show that <code>tesswcs</code> is able to accurately predict the WCS of a TESS camera and CCD given the boresight RA, Dec, and Roll, let's create a predicted WCS. To predict a WCS we use the <code>predict</code> method, and pass an RA, Dec and Roll. </p> <pre><code>wcs_predicted = WCS.predict(wcs.ra, wcs.dec, wcs.roll, camera=1, ccd=1)\n</code></pre> <pre><code>wcs_predicted\n</code></pre> <pre><code>WCS Keywords\n\nNumber of WCS axes: 2\nCTYPE : 'RA---TAN-SIP'  'DEC--TAN-SIP'  \nCRVAL : 319.40931664794107  -41.2748366984738  \nCRPIX : 1046.1403996643921  1002.0036834114205  \nPC1_1 PC1_2  : -0.0054812525828552925  0.0017288395822421384  \nPC2_1 PC2_2  : 0.0015904886653827649  0.005438761744971495  \nCDELT : -1.0  1.0  \nNAXIS : 2078  2136\n</code></pre> <p>You can see the predicted WCS has slightly different properties, (e.g. the predicted WCS uses a different origin in pixel space).</p> <p>Let's compare the world coordinates that would be given by pixels on the detector in each case.</p> <pre><code># Build a pixel grid, note we include collateral pixels\nR, C = np.meshgrid(\n    np.arange(0, 2078, 10), np.arange(0, 2136, 10), indexing=\"ij\"\n)\n</code></pre> <p>Below we plot the pixel grid</p> <pre><code>fig, ax = plt.subplots()\nax.scatter(C, R, s=0.1, color='grey', label='True Measured WCS')\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title=\"Sector 1, Camera 1, CCD 1\")\n</code></pre> <pre><code>[Text(0.5, 0, 'Column [pixel]'),\n Text(0, 0.5, 'Row [pixel]'),\n Text(0.5, 1.0, 'Sector 1, Camera 1, CCD 1')]\n</code></pre> <p></p> <p>Since <code>WCS</code> is a subclass of <code>astropy.wcs.WCS</code> we can use the <code>pixel_to_world</code> method</p> <pre><code>c = wcs.pixel_to_world(R, C)\n</code></pre> <p><code>c</code> now contains the sky coordinates for those pixel positions. Let's plot them.</p> <pre><code>fig, ax = plt.subplots()\nax.scatter(c.ra.deg, c.dec.deg, s=0.1, color='grey', label='True Measured WCS')\nax.set(xlabel='RA [deg]', ylabel='Dec [deg]', title=\"Sector 1, Camera 1, CCD 1\")\n</code></pre> <pre><code>[Text(0.5, 0, 'RA [deg]'),\n Text(0, 0.5, 'Dec [deg]'),\n Text(0.5, 1.0, 'Sector 1, Camera 1, CCD 1')]\n</code></pre> <p></p> <p>Looks great. Now we can plot the predicted coordinates for the same RA, Dec, and Roll as sector 1.</p> <pre><code>c_predicted = wcs_predicted.pixel_to_world(R, C)\n</code></pre> <pre><code>fig, ax = plt.subplots()\nax.scatter(c.ra.deg, c.dec.deg, s=0.1, color='grey', label='True Measured WCS')\nax.scatter(c_predicted.ra.deg, c_predicted.dec.deg, s=0.1, color='red', label='Predicted WCS')\nax.legend()\nax.set(xlabel='RA [deg]', ylabel='Dec [deg]', title=\"Sector 1, Camera 1, CCD 1\")\n</code></pre> <pre><code>[Text(0.5, 0, 'RA [deg]'),\n Text(0, 0.5, 'Dec [deg]'),\n Text(0.5, 1.0, 'Sector 1, Camera 1, CCD 1')]\n</code></pre> <p></p> <p>These look very close! Let's look at the separation between the truth and the prediction as a function of pixel position.</p> <pre><code>sep = np.hypot(c.ra - c_predicted.ra, c.dec - c_predicted.dec).to('arcsec')\n</code></pre> <pre><code>fig, ax = plt.subplots()\nim = ax.pcolormesh(C, R, sep.value)\ncbar = plt.colorbar(im, ax=ax)\ncbar.set_label(\"True TESS WCS - Predicted WCS [arcsecond]\")\nax.set(xlabel='Column [pixel]', ylabel='Row [pixel]', title=\"Sector 1, Camera 1, CCD 1\");\n</code></pre> <p></p> <p>Given that a TESS pixel is 21 arcseconds across, the prediction is within a tenth of a pixel across the detector!</p> <p>The <code>tesswcs.WCS.predict</code> method is generally accurate to a fraction of a pixel.</p>"},{"location":"tutorial/#creating-new-wcs-based-on-pointing-information","title":"Creating new WCS based on pointing information","text":"<p>Some TESS sectors have not yet been observed, and therefore there is no WCS data archived for those sectors. In these cases, we can predict the WCS based on the RA, Dec and Roll for the upcoming sectors. </p> <p><code>tesswcs</code> stores the pointing data for all TESS sectors in the <code>pointings</code> variable, to make this easier.</p> <p>Below we show how to predict the WCS for a future TESS pointing from the upcoming Cycle 7.</p> <pre><code># We will need to use astropy units for plotting\nimport astropy.units as u\n# The `footprint` function is a convenience function to obtain the edges of the CCD\nfrom tesswcs.utils import footprint\n\n# We will also create an ecliptic plane vector for plotting purposes\nfrom astropy.coordinates import SkyCoord\necliptic_plane = SkyCoord(np.arange(0, 360, 1), np.arange(0, 360, 1)*0, unit='deg', frame='geocentricmeanecliptic').transform_to('icrs')\n</code></pre> <p>First we get the pointing data for a sector in cycle 7</p> <pre><code>from tesswcs import pointings\n</code></pre> <pre><code>sector = 90\npointings[pointings['Sector'] == sector]\n</code></pre> Table length=1 CycleSectorRADecRollStartEnd int64int64float64float64float64float64float64 790155.0705-51.7243141.94592460746.52460774.5 <p>We only need RA, Dec, and Roll</p> <pre><code># Boresight RA, Dec, and Roll\nra, dec, roll = np.asarray(pointings[pointings['Sector'] == sector][['RA', 'Dec', 'Roll']])[0]\n</code></pre> <p>We can obtain the predicted WCS for this roll for any camera and CCD using the following</p> <pre><code>wcs = WCS.predict(ra, dec, roll, camera=1, ccd=1)\n</code></pre> <p>Below we show a short script to plot the edges of each CCD in this sector in a Mollweide projection</p> <pre><code># Set up plot parameters\nfig = plt.figure(figsize=(10, 5))\nax = fig.add_subplot(111, projection=\"mollweide\")\nax.grid(True)\nax.set(\n    title=f\"Predicted WCS for RA: {ra}, Dec: {dec}, Roll: {roll}\\n[i.e. Sector {sector} Pointing]\",\n    xlabel=\"RA\",\n    ylabel=\"Dec\",\n)\n# Plot the ecliptic plane\ns = np.argsort(ecliptic_plane.ra.wrap_at(180 * u.deg).rad)\nplt.plot(ecliptic_plane.ra.wrap_at(180 * u.deg).rad[s], ecliptic_plane.dec.rad[s], color='grey', zorder=-10, alpha=0.5, lw=10)\n\n# iterate over camera, CCD\nfor camera in np.arange(1, 5):\n    for ccd in np.arange(1, 5):\n        # predict the WCS\n        wcs = WCS.predict(ra, dec, roll, camera=camera, ccd=ccd)\n        # create world coordinates from a pixel footprint\n        c = wcs.pixel_to_world(*footprint().T)\n\n        # Plot each camera/CCD\n        ax.scatter(\n            c.ra.wrap_at(180 * u.deg).rad,\n            c.dec.rad,\n            lw=0.5,\n            s=0.1,\n            c=f\"C{camera - 1}\",\n        )\n</code></pre> <p></p>"},{"location":"tutorial/#creating-a-wcs-based-on-an-ra-dec-and-roll","title":"Creating a WCS based on an RA, Dec, and Roll","text":"<p>Sometimes we may want to obtain a WCS for a theoretical pointing of the spacecraft. To do so you can easily add your own boresight RA, Dec, and Roll. Below I show the same proceedure as above for a random pointing.</p> <pre><code># Boresight RA, Dec, and Roll\nra, dec, roll = 239.4578, 12.56087, 42.45899\n</code></pre> <pre><code># Set up plot parameters\nfig = plt.figure(figsize=(10, 5))\nax = fig.add_subplot(111, projection=\"mollweide\")\nax.grid(True)\nax.set(\n    title=f\"Predicted WCS for RA: {ra}, Dec: {dec}, Roll: {roll}\",\n    xlabel=\"RA\",\n    ylabel=\"Dec\",\n)\n# Plot the ecliptic plane\ns = np.argsort(ecliptic_plane.ra.wrap_at(180 * u.deg).rad)\nplt.plot(ecliptic_plane.ra.wrap_at(180 * u.deg).rad[s], ecliptic_plane.dec.rad[s], color='grey', zorder=-10, alpha=0.5, lw=10)\n\n\n# iterate over camera, CCD\nfor camera in np.arange(1, 5):\n    for ccd in np.arange(1, 5):\n        # predict the WCS\n        wcs = WCS.predict(ra, dec, roll, camera=camera, ccd=ccd)\n        # create world coordinates from a pixel footprint\n        c = wcs.pixel_to_world(*footprint().T)\n\n        # Plot each camera/CCD\n        ax.scatter(\n            c.ra.wrap_at(180 * u.deg).rad,\n            c.dec.rad,\n            lw=0.5,\n            s=0.1,\n            c=f\"C{camera - 1}\",\n        )\n</code></pre> <p></p>"},{"location":"tutorial/#using-the-wcs-object-to-find-if-objects-are-observable-in-tess","title":"Using the WCS Object to find if objects are observable in TESS","text":"<p>Now that we have a WCS will want to use it. The key use case of WCS is a way to convert between sky positions of targets, and pixel positions on the detector. </p> <p>Let's take a look at an exoplanet target. First we obtain the coordinates as an <code>astropy.coordinates.SkyCoord</code> object, using the <code>from_name</code> class method.</p> <pre><code>c_targ = SkyCoord.from_name('HD209458')\n</code></pre> <pre><code>c_targ\n</code></pre> <pre><code>&lt;SkyCoord (ICRS): (ra, dec) in deg\n    (330.79488644, 18.88431928)&gt;\n</code></pre> <p>Now that we have the coordinate that we want, let's see if it is observable in Cycle 6. First we need to know what sectors were taken during cycle 6.</p> <pre><code>sectors = pointings['Sector'][pointings['Cycle'] == 6].data\nsectors\n</code></pre> <pre><code>array([70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83])\n</code></pre> <p>Using the <code>pointings</code> table we can see it's sectors 70 through 83. </p> <p>We can now build the WCS for TESS each of those sectors. For each camera and CCD, we use the <code>footprint_contains</code> method to check if the target is contained within the CCD.</p> <pre><code>observable = []\nfor sector in sectors:\n    ra, dec, roll = pointings[sector - 1][['RA', 'Dec', 'Roll']]\n    for camera in np.arange(1, 5):\n        for ccd in np.arange(1, 5):\n            # predict the WCS\n            wcs = WCS.predict(ra, dec, roll, camera=camera, ccd=ccd)\n            # check if the target falls inside the CCD\n            if wcs.footprint_contains(c_targ):\n                print(f\"Target Observable in Sector {sector}, Camera {camera}, CCD {ccd}\")\n</code></pre> <pre><code>Target Observable in Sector 82, Camera 1, CCD 1\n</code></pre> <p>It looks like the target is observable in sector 82! Let's find out what pixel the target will fall on</p> <pre><code>sector = 82\nra, dec, roll = pointings[sector - 1][['RA', 'Dec', 'Roll']]\nwcs = WCS.predict(ra, dec, roll, camera=1, ccd=1)\n</code></pre> <pre><code>row_pixel, column_pixel = wcs.world_to_pixel(c_targ)\n</code></pre> <pre><code>row_pixel, column_pixel\n</code></pre> <pre><code>(array(506.32115277), array(454.32962391))\n</code></pre> <p>It looks like this target will fall on row 506, column 454. Keep in mind, this includes collateral pixels! You can read more about collateral pixels on TESS CCDs here.</p>"}]}